(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{423:function(e,t,o){"use strict";o.r(t);var s=o(42),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"dynamic-programming"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#dynamic-programming"}},[e._v("#")]),e._v(" Dynamic Programming")]),e._v(" "),o("p",[e._v("We know what a "),o("em",[e._v("divide-and-conquer")]),e._v(" algorithm is. We break the problem into subproblems and solve those. Then we combine the answers from the subproblems.")]),e._v(" "),o("p",[e._v("The subproblems sometimes "),o("em",[e._v("overlap")]),e._v(". In that case, if you solve a subproblem, you may wish to save its solution so that you can reuse it if you encounter this subproblem again. This is called "),o("em",[e._v("memoization")]),e._v(".")]),e._v(" "),o("p",[e._v("Divide-and-conquer is not the only way to formulate subproblems. The Floyd-Warshall algorithm is a good example. Here we start with a table of shortest paths between pairs of vertices, with the restriction that we pass through no intermediate vertex. We then step-by-step relax this constraint, allowing ourself to pass through more vertices.")]),e._v(" "),o("p",[e._v("This is not a divide-and-conquer approach. We didn't try to solve the problem with half the vertices or half the edges. Breaking up a problem like that would be "),o("em",[e._v("top-down")]),e._v(".")]),e._v(" "),o("p",[e._v("Instead, we started from the "),o("em",[e._v("bottom")]),e._v(": problems with no intermediate vertices. We then moved "),o("em",[e._v("up")]),e._v(", putting together these solutions to solve more relaxed problems. This is called a "),o("em",[e._v("bottom-up approach")]),e._v(".")]),e._v(" "),o("p",[e._v("An advantage to this bottom-up approach is that memoization can be wasteful in storing unnecessary solutions. In Floyd-Warshall we use exactly "),o("code",[e._v("O(n**2)")]),e._v(" memory, which is optimal.")]),e._v(" "),o("p",[e._v("The "),o("em",[e._v("dynamic")]),e._v(" part of the name might be thought to come from starting with solutions to subproblems, and then, over "),o("em",[e._v("time")]),e._v(", producing new solutions to new problems, growing toward your answer. It's a tortured name (Bellman admits this), but there is some logic to it.")])])}),[],!1,null,null,null);t.default=a.exports}}]);