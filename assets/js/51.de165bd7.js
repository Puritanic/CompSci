(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{341:function(t,s,e){"use strict";e.r(s);var a=e(28),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[e("img",{attrs:{src:"https://thepracticaldev.s3.amazonaws.com/i/mzfpomwt6xfadtk9lpei.png",alt:"Alt text of image"}})]),t._v(" "),e("p",[t._v("_ Note that the most of the code is tested only with the "),e("code",[t._v("bash")]),t._v(" and "),e("code",[t._v("zsh")]),t._v(" shells, it may not work with other shells._")]),t._v(" "),e("p",[e("strong",[t._v("Conditional execution")]),t._v(" means that you can choose to execute code only if certain conditions are met. Without this capability, all you would be able to do is execute one command after another after another. The ability to test a variety of things about the state of the system, and of the environment variables of the process, means that a shell script can do far more powerful things that would otherwise be possible. In this post, we are going to explore "),e("code",[t._v("test operators")]),t._v(", "),e("code",[t._v("if/then/else")]),t._v("conditionals, and "),e("code",[t._v("case")]),t._v(" statements.")]),t._v(" "),e("h3",{attrs:{id:"test-aka"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#test-aka"}},[t._v("#")]),t._v(" "),e("code",[t._v("test")]),t._v(" aka "),e("code",[t._v("[")])]),t._v(" "),e("p",[t._v("With tests we can check for example: if the file exists, if a number is greater than another, compare if strings are equal...")]),t._v(" "),e("p",[t._v("Syntax:")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" condition-to-test-for "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),e("p",[t._v("Example:")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" -e /etc/passwd "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),e("p",[t._v("As heading above says, another name for "),e("code",[t._v("test")]),t._v(" is "),e("code",[t._v("[")]),t._v(". It is also a shell builtin (which means that the shell itself will interpret "),e("code",[t._v("[")]),t._v(" as "),e("code",[t._v("test")]),t._v(", even if your Unix environment is set up differently). When "),e("code",[t._v("[")]),t._v(" is called, it requires a "),e("code",[t._v("]")]),t._v(" around its arguments, but otherwise, it does the same work.")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("test")]),t._v("  -e /etc/passwd\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# as above so below")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" -e /etc/passwd "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),e("p",[t._v("This tests if "),e("code",[t._v("etc/passwd")]),t._v(" exists, and if it does this returns "),e("code",[t._v("true")]),t._v(" - command exit status of "),e("code",[t._v("0")]),t._v(". If it doesn't exist the command exits with the exit status of "),e("code",[t._v("1")]),t._v(" (more on exit statuses in next post).")]),t._v(" "),e("p",[e("strong",[t._v("Gotcha")]),t._v(": The spaces around the "),e("code",[t._v("[")]),t._v(" and "),e("code",[t._v("]")]),t._v(" symbols are required! For example: "),e("code",[t._v("[-e /etc/passwd ]")]),t._v(" will not work; it is interpreted as "),e("code",[t._v("test-e /etc/passwd ]")]),t._v(" which errors because "),e("code",[t._v("]")]),t._v(" doesn't have a beginning "),e("code",[t._v("[")]),t._v(". "),e("code",[t._v("[")]),t._v(" is actually a program, and just like "),e("code",[t._v("ls")]),t._v(" and other programs, it must be surrounded by spaces. "),e("strong",[t._v("Moral of the story: Put spaces around all your operators.")])]),t._v(" "),e("p",[e("em",[t._v("Note")]),t._v(": You can reverse the results of the test with "),e("code",[t._v("!")]),t._v(":")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v(" -r “"),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$1")]),t._v("” "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("then")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"File '),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$1")]),t._v(' is not readable – skipping."')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fi")]),t._v("\n")])])]),e("p",[t._v("As you can see "),e("code",[t._v("test")]),t._v(" is a simple but powerful comparison utility. For full details, run "),e("code",[t._v("man test")]),t._v(" on your system, but here are some usages and typical examples:")]),t._v(" "),e("p",[t._v("File test operators:")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[t._v("-d FILE "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#True if the file is a directory")]),t._v("\n-e FILE "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#True if the file exists")]),t._v("\n-f FILE "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#True if the file exists and it's regular file")]),t._v("\n-r FILE "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#True if the file is readable by you")]),t._v("\n-s FILE "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#True if the file exists and it's not empty")]),t._v("\n-w FILE "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#True if the file is writable by you")]),t._v("\n-x FILE "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#True if the file is executable by you")]),t._v("\n")])])]),e("p",[t._v("String test operators:")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[t._v("-z STRING "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#True if the string is empty")]),t._v("\n-n STRING "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#True if the string is not empty")]),t._v("\nSTRING1 "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" STRING2 "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#True if the strings are equal")]),t._v("\nSTRING1 "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" STRING2 "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#True if the strings are not equal")]),t._v("\n")])])]),e("p",[t._v("Arithmetic tests:")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[t._v("arg1 -eq arg2 "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#True if the arguments are equal")]),t._v("\narg1 -ne arg2 "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#True if the arguments are not equal")]),t._v("\narg1 -lt arg2 "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#True if the arg1 is less than arg2")]),t._v("\narg1 -le arg2 "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#True if arg1 is less than or equal to arg2")]),t._v("\narg1 -gt arg2 "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#True if arg1 is greater than arg2")]),t._v("\narg1 -ge arg2 "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#True if arg1 is greater than or equal to arg2")]),t._v("\n")])])]),e("h3",{attrs:{id:"and"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#and"}},[t._v("#")]),t._v(" "),e("code",[t._v("&&")]),t._v(" and "),e("code",[t._v("||")])]),t._v(" "),e("p",[t._v("It is possible to combine tests, and/or chain multiple commands by using the "),e("code",[t._v("&&")]),t._v(" and "),e("code",[t._v("||")]),t._v(" operators. These perform a Logical AND and Logical OR, respectively.")]),t._v(" "),e("ul",[e("li",[e("p",[e("code",[t._v("&& = AND")]),t._v(" "),e("code",[t._v("mkdir /tmp/bak && cp test.txt /tmp/bak")])]),t._v(" "),e("p",[t._v("The command that follows "),e("code",[t._v("&&")]),t._v(" will be executed if and only the previous command succeeds (aka exits with "),e("code",[t._v("0")]),t._v(" exit status).")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("|| = OR")]),t._v(" "),e("code",[t._v("cp test.txt /tmp/bak || cp test.txt /tmp")])]),t._v(" "),e("p",[t._v("The "),e("code",[t._v("||")]),t._v(" operator performs a Logical OR, so when it only matters that one of the conditions is met, but not which one, this is the feature to use.")])])]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token shebang important"}},[t._v("#! /bin/bash")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("HOST")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"google.com"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("ping")]),t._v(" -c "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$HOST")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"'),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$HOST")]),t._v(' reachable."')]),t._v("\n")])])]),e("hr"),t._v(" "),e("h3",{attrs:{id:"if-then"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#if-then"}},[t._v("#")]),t._v(" IF/THEN")]),t._v(" "),e("p",[t._v("Almost every programming language has an if/then/else construct, and the shell is no exception. The syntax uses square brackets to perform a test, and the "),e("code",[t._v("then")]),t._v(" and "),e("code",[t._v("fi")]),t._v(" statements are required, acting just like the { and } curly brackets in C and some other languages.")]),t._v(" "),e("p",[t._v("Syntax:")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" condition "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("then")]),t._v("\n    statements "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" when the condition is "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fi")]),t._v("\n")])])]),e("p",[t._v("Other than the line break after the "),e("code",[t._v("then")]),t._v(", all these line breaks are required or can be replaced with semicolons. To remind: the spaces around the "),e("code",[t._v("[")]),t._v(" and "),e("code",[t._v("]")]),t._v(" symbols are also required, so this can be reduced (pls don't) at best to: "),e("code",[t._v("if [ condition ];then statements;fi")])]),t._v(" "),e("blockquote",[e("p",[t._v("It is quite common to use the semicolon to put the then on the same line as the if.")])]),t._v(" "),e("p",[t._v("Example:")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("MY_SHELL")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"zsh"')]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"'),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$MY_SHELL")]),t._v('"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"zsh"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("then")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"You are the zsh shell user!"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fi")]),t._v("\n")])])]),e("h4",{attrs:{id:"else"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#else"}},[t._v("#")]),t._v(" ELSE")]),t._v(" "),e("p",[t._v("It may be that you want to run the command if possible, but if it can’t be done, then continue execution of the script. One (simpler and the most common) way to do this would be to use ELSE statement:")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" condition "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("then")]),t._v("\n    statements "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" when the condition is "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v("\n    statements "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" when the condition is "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fi")]),t._v("\n")])])]),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token shebang important"}},[t._v("#!/bin/bash")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Check for likely causes of failure")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" -r "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"'),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$1")]),t._v('"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("then")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("cat")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"'),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$1")]),t._v('"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Error: '),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$1")]),t._v(' is not a readable file."')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fi")]),t._v("\n")])])]),e("p",[t._v("This snippet tries to "),e("code",[t._v("cat")]),t._v(" the file passed to it as its first parameter ("),e("code",[t._v('"$1"')]),t._v(" putting double quotes around it to allow for filenames including spaces) and spits out an error message if it failed to do so.")]),t._v(" "),e("h4",{attrs:{id:"elif"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#elif"}},[t._v("#")]),t._v(" ELIF")]),t._v(" "),e("p",[e("code",[t._v("elif")]),t._v(" is a construct that allows you to add conditions to the "),e("code",[t._v("else")]),t._v(" part of an "),e("code",[t._v("if")]),t._v(' statement. It is short for "else if" so that a long string of possible actions can be written more concisely. This makes it easier to write, easier to read, and most importantly, easier to debug.')]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token shebang important"}},[t._v("#!/bin/bash")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("OS")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token variable"}},[e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("uname")]),t._v(" -s"),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"'),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$OS")]),t._v('"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"FreeBSD"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("then")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"This Is FreeBSD"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("elif")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"'),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$OS")]),t._v('"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"CYGWIN_NT-5.1"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("then")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"This is Cygwin"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("elif")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"'),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$OS")]),t._v('"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"SunOS"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("then")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"This is Solaris"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("elif")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"'),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$OS")]),t._v('"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Darwin"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("then")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"This is Mac OSX"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("elif")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"'),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$OS")]),t._v('"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Linux"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("then")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"This is Linux"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Failed to identify this OS"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fi")]),t._v("\n")])])]),e("p",[t._v("This is "),e("em",[t._v("much")]),t._v(", "),e("em",[t._v("much")]),t._v(" more readable than the nested "),e("code",[t._v("else")]),t._v(" code hell this could turn into.")]),t._v(" "),e("hr"),t._v(" "),e("h3",{attrs:{id:"case-statement"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#case-statement"}},[t._v("#")]),t._v(" "),e("code",[t._v("case")]),t._v(" statement")]),t._v(" "),e("p",[e("code",[t._v("case")]),t._v(" provides a much cleaner, easier-to-write, and far more readable alternative to the "),e("code",[t._v("if/then/else")]),t._v(" construct, particularly when there are a lot of possible values to test for. With case, you list the values you want to identify and act upon, and then provide a block of code for each one. One common place for case statements use are system startup scripts. Syntax:")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"'),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$VAR")]),t._v('"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v("\n    pattern_1"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Some commands here.")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Execution will stop when the double semicolon is reached")]),t._v("\n    pattern_n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Some commands here.")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("esac")]),t._v("\n")])])]),e("p",[t._v("Example:")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token shebang important"}},[t._v("#!/bin/bash")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("OS")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token variable"}},[e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("uname")]),t._v(" -s"),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"'),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$OS")]),t._v('"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v("\n    FreeBSD"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"This is FreeBSD"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    CYGWIN_NT-5.1"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"This is Cygwin"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    SunOS"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"This is Solaris"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    Darwin"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"This is Mac OSX"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    Linux"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"This is Linux"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    *"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Failed to identify this OS"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("esac")]),t._v("\n")])])]),e("p",[t._v("Although it looks like a special directive, the "),e("code",[t._v("*")]),t._v(" is simply the most generic wildcard possible, as it will match absolutely any string. This also suggests that we are able to do more advanced pattern matching like "),e("code",[t._v("RegEx")]),t._v(", for example.")]),t._v(" "),e("blockquote",[e("p",[t._v("Note that the patterns are case sensitive.")])]),t._v(" "),e("p",[t._v("A less well-known feature of the bash implementation of "),e("code",[t._v("case")]),t._v(" is that you can end the statement with "),e("code",[t._v(";;&")]),t._v(" or "),e("code",[t._v(";&")]),t._v(" instead of only "),e("code",[t._v(";;")]),t._v(". While "),e("code",[t._v(";;")]),t._v(" means that none of the other statements will be executed, if you end a statement with "),e("code",[t._v(";;&")]),t._v(" all subsequent cases will still be evaluated. If you end a statement with "),e("code",[t._v(";&")]),t._v(", the case will be treated as having matched.")]),t._v(" "),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token shebang important"}},[t._v("#!/bin/bash")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("read")]),t._v(" -p "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Give me a word: "')]),t._v(" input\n"),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" -en "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"That\'s "')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$input")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v("\n  *"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(":digit:"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("*"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" -en "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"numerical "')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("\n  *"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(":lower:"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("*"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" -en "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"lowercase "')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("\n  *"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(":upper:"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("*"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" -en "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"uppercase "')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("\n  *"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"input."')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("esac")]),t._v("\n\n$ ./case1.sh\nGive me a word: Hello "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("123")]),t._v("\nThat's numerical lowercase uppercase input.\n")])])]),e("blockquote",[e("p",[t._v("This feature is specific to the bash shell; it is not a standard feature of the Bourne shell, so if you need to write a portable script, do not expect this to work. It will cause a syntax error message on other shells.")])]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("This post has covered the various ways of controlling conditional execution — from the simple "),e("code",[t._v("if/then/else construct")]),t._v(", through the different things that can be done with "),e("code",[t._v("test")]),t._v(", through to the more flexible "),e("code",[t._v("case")]),t._v(" statement for matching against different sets of input.")]),t._v(" "),e("p",[t._v("I must admit that writing about shell programming seemed like two or three posts tops in the beginning, but there is a "),e("em",[t._v("lot")]),t._v(" to be covered, and even this and previous posts are not even the half of everything that can be learned about topics I've written about. I really recommend "),e("a",{attrs:{href:"http://tldp.org/LDP/abs/html/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Advanced Bash-Scripting Guide"),e("OutboundLink")],1),t._v(" and "),e("a",{attrs:{href:"http://shop.oreilly.com/product/9780596005955.do",target:"_blank",rel:"noopener noreferrer"}},[t._v("Classic Shell Scripting"),e("OutboundLink")],1),t._v(" if you want to learn shell programming in more depth. I'll write a bit about Positional parameters, exit codes and (hopefully) functions in the next one. Thanks for reading!")])])}),[],!1,null,null,null);s.default=n.exports}}]);